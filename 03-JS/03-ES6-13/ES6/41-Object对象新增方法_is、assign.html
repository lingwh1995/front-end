<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object对象新增方法_is、assign</title>
  <script>
    //1.Object.is 判断两个值是否完全相等，用法和 === 基本一样，注意在 判断两个 NaN 是否相等的时候返回的结果是不同的
    console.log(Object.is(100,100))
    console.log(Object.is(100,'100'))
    console.log(Object.is(NaN,NaN))
    console.log(NaN === NaN)
    console.log('------------01------------')


    /**
     * 2.Object.assign 合并对象
     *    特别注意:1.Object.assign合并数组时,会把数组视为对象处理  2.合并数组最好选择 ...扩展运算符
     */
    const cat = {name:'小肥', color:'white'}
    const source1 = {
      id: '001',
      name: '张三',
      hobby: '抽烟',
      pet: cat
    }
    const source2 = {
      id: '002',
      name: '李四',
    }
    let target = {}
    console.log(source1)
    console.log(source2)
    console.log(target)
    console.log('---------开始时source1、source2、target对象---------')

    /**
     * 合并对象方式一  Object.assign(obj1,obj2)
     *    1.如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
     *    2.合并结果会放在第一个参与合并的对象中，会对参与合并的第一个对象产生影响
     *    3.Object.assign方法是浅复制，不是深复制，也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝的是这个对象的引用
     */
    target = Object.assign(target,source1, source2)
    console.log(target)
    console.log('---------Object.assign()合并对象---------')
    /**
     * 合并对象方式二   ...扩展运算符
     *    1.如果多个源对象有同名属性，则后面的属性会覆盖前面的属性。
     *    2.合并结果会放在一个新的对象中，不会对参与合并和任何一个对象产生影响
     *    3....扩展运算符是浅复制，不是深复制，也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝的是这个对象的引用
     */ 
    console.log({...source1, ...source2})
    console.log('---------...扩展运算符合并对象---------')

    console.log(source1)
    console.log(source2)
    console.log(target)
    console.log('---------结束时source1、source2、target对象---------')
    
    //目标对象有1，2，3属性，源对象有4，5值，如果使用Object.assign的话，那么源对象中4，5的键和目标对象中的1，2的键是相同的，因此值直接替换掉
    const targetArrs = [1, 2, 3];
    const sourceArrs = [4, 5];
    Object.assign(targetArrs, sourceArrs);
    console.log(targetArrs);  // [4, 5, 3]
    console.log('------------02------------')


    /**
     * 3.设置原型对象和获取原型对象
     *  Object.setPrototypeOf(obj, proto) 设置原型对象
     *      obj：要设置原型对象的对象
     *      proto：该对象的新原型对象或null，否则抛出TypeError异常
     *   Object.getPrototypeof(obj) 获取原型对象
     *      obj：要获取prototype对象的对象
     */ 
    const person = {
      name: '人类'
    }
    const man = {
        name: '男人'
    }
    Object.setPrototypeOf(man, person)
    console.log(Object.getPrototypeOf(man))
    console.log(man)
    console.log('------------03------------')
  </script>
</head>
<body>
  
</body>
</html>